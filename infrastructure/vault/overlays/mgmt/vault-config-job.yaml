# infrastructure/vault/overlays/mgmt/vault-config-job.yaml
#
# Production-grade Vault initialisation job.
#
# Key security properties:
#   1. No hardcoded credentials — passwords generated at runtime with openssl
#   2. No root token in git — annotated clearly as dev-mode only
#   3. Least-privilege RBAC — init SA can only read the cluster-ips secret
#   4. Idempotent — safe to re-run, will not overwrite real credentials
#   5. kind-specific overrides are clearly labeled
#
# NOTE ON VAULT_TOKEN IN DEV vs PROD:
#   kind/dev:  Vault runs in dev mode (storage: inmem, auto-unsealed, root token
#              is the well-known string "root"). Acceptable ONLY because the
#              cluster is ephemeral and not network-accessible.
#   production: Use a scoped bootstrap token created from the initial root token,
#              stored in AWS SSM / GCP Secret Manager, injected at runtime.
#              Revoke the initial root token immediately after first setup.
#              The root token must NEVER appear in git or CI logs in prod.
# ==============================================================================

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault-init-sa
  namespace: vault
  annotations:
    argocd.argoproj.io/sync-wave: "1"

---
# Least privilege: only read the cluster-ips secret in the vault namespace.
# No cluster-admin, no wildcards.
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: vault-init-role
  namespace: vault
  annotations:
    argocd.argoproj.io/sync-wave: "1"
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    resourceNames: ["cluster-ips"]
    verbs: ["get"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: vault-init-rolebinding
  namespace: vault
  annotations:
    argocd.argoproj.io/sync-wave: "1"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: vault-init-role
subjects:
  - kind: ServiceAccount
    name: vault-init-sa
    namespace: vault

---
apiVersion: batch/v1
kind: Job
metadata:
  name: vault-init-config
  namespace: vault
  annotations:
    argocd.argoproj.io/sync-wave: "2"
  labels:
    app.kubernetes.io/managed-by: argocd
spec:
  ttlSecondsAfterFinished: 300
  template:
    spec:
      restartPolicy: OnFailure
      serviceAccountName: vault-init-sa
      containers:
        - name: vault-init
          image: hashicorp/vault:1.17.0
          resources:
            requests:
              cpu: 50m
              memory: 64Mi
            limits:
              cpu: 100m
              memory: 128Mi
          env:
            - name: VAULT_ADDR
              value: "http://vault.vault.svc.cluster.local:8200"
            # KIND/DEV ONLY — see NOTE above
            # PRODUCTION: replace with secretKeyRef from your secret manager
            - name: VAULT_TOKEN
              value: "root"
            - name: DEV_CLUSTER_IP
              valueFrom:
                secretKeyRef:
                  name: cluster-ips
                  key: dev-ip
            - name: STAGING_CLUSTER_IP
              valueFrom:
                secretKeyRef:
                  name: cluster-ips
                  key: staging-ip
          command:
            - /bin/sh
            - -c
            - |
              set -e

              # ----------------------------------------------------------------
              # WAIT FOR VAULT
              # ----------------------------------------------------------------
              echo "[1/7] Waiting for Vault to be ready..."
              until vault status > /dev/null 2>&1; do
                echo "  Vault not ready yet, retrying in 3s..."
                sleep 3
              done
              echo "  Vault is ready."

              # ----------------------------------------------------------------
              # SECRETS ENGINE
              # ----------------------------------------------------------------
              echo "[2/7] Enabling KV v2 secrets engine..."
              vault secrets enable -path=secret kv-v2 2>/dev/null \
                || echo "  KV engine already enabled."

              # ----------------------------------------------------------------
              # IDEMPOTENCY GUARD
              #
              # Read current password from Vault.
              # Known seed values that must be replaced:
              #   - empty string (never written)
              #   - "changeme123" (old hardcoded value from previous job versions)
              #   - "n/a" (Vault display value for empty fields)
              #
              # If current password is none of these, real credentials exist
              # and we must not overwrite them.
              # ----------------------------------------------------------------
              echo "[3/7] Checking if real credentials already exist..."
              CURRENT_PASSWORD=$(vault kv get -field=admin-password secret/grafana 2>/dev/null || echo "")

              is_seed_value() {
                case "$1" in
                  ""|"changeme123"|"n/a") return 0 ;;  # is a seed value
                  *) return 1 ;;                        # is a real value
                esac
              }

              if is_seed_value "$CURRENT_PASSWORD"; then
                echo "  Seed or missing credentials detected. Generating real credentials..."
                SKIP_SECRET_GENERATION=false
              else
                echo "  Real credentials already exist. Skipping generation."
                SKIP_SECRET_GENERATION=true
              fi

              # ----------------------------------------------------------------
              # GENERATE AND WRITE SECRETS (first run only)
              #
              # Uses openssl — works on Linux and macOS, present in the Vault
              # container image. Produces a 32-char alphanumeric string with
              # ~190 bits of entropy. No shell-special characters.
              # ----------------------------------------------------------------
              if [ "$SKIP_SECRET_GENERATION" = "false" ]; then
                echo "[4/7] Generating strong random credentials..."

                GRAFANA_PASSWORD=$(openssl rand -base64 32 | tr -d '=/+' | cut -c1-32)
                ARGOCD_PASSWORD=$(openssl rand -base64 32 | tr -d '=/+' | cut -c1-32)

                # Validate — fail loudly if generation produced an empty string
                [ -z "$GRAFANA_PASSWORD" ] && echo "ERROR: Grafana password generation failed" && exit 1
                [ -z "$ARGOCD_PASSWORD" ]  && echo "ERROR: ArgoCD password generation failed"  && exit 1

                echo "  Writing Grafana credentials to Vault..."
                vault kv put secret/grafana \
                  admin-user=admin \
                  admin-password="${GRAFANA_PASSWORD}"

                echo "  Writing ArgoCD credentials to Vault..."
                vault kv put secret/argocd \
                  admin-password="${ARGOCD_PASSWORD}"

                # Print credentials ONCE to pod logs.
                # Retrieve with:
                #   kubectl logs -n vault -l job-name=vault-init-config
                # Logs are ephemeral — not stored in git or K8s etcd.
                # PRODUCTION: pipe directly to AWS SSM / GCP Secret Manager instead.
                echo ""
                echo "================================================================"
                echo "  BOOTSTRAP CREDENTIALS — retrieve once, then store securely  "
                echo "  kubectl logs -n vault -l job-name=vault-init-config          "
                echo "================================================================"
                echo "  Grafana  → admin / ${GRAFANA_PASSWORD}"
                echo "  ArgoCD   → admin / ${ARGOCD_PASSWORD}"
                echo "================================================================"
                echo ""
              else
                echo "[4/7] Skipping secret generation — real credentials exist."
              fi

              # ----------------------------------------------------------------
              # KUBERNETES AUTH — always re-applied for idempotency
              # ----------------------------------------------------------------
              echo "[5/7] Configuring Kubernetes auth methods..."

              vault auth enable -path=kubernetes/mgmt kubernetes 2>/dev/null \
                || echo "  kubernetes/mgmt already enabled."
              vault write auth/kubernetes/mgmt/config \
                kubernetes_host="https://kubernetes.default.svc.cluster.local:443"

              # KIND-SPECIFIC: insecure_tls=true acceptable for ephemeral local clusters only.
              # PRODUCTION: provide the CA bundle from each spoke cluster's kubeconfig.
              vault auth enable -path=kubernetes/dev kubernetes 2>/dev/null \
                || echo "  kubernetes/dev already enabled."
              vault write auth/kubernetes/dev/config \
                kubernetes_host="https://${DEV_CLUSTER_IP}:6443" \
                insecure_tls=true

              vault auth enable -path=kubernetes/staging kubernetes 2>/dev/null \
                || echo "  kubernetes/staging already enabled."
              vault write auth/kubernetes/staging/config \
                kubernetes_host="https://${STAGING_CLUSTER_IP}:6443" \
                insecure_tls=true

              # ----------------------------------------------------------------
              # POLICIES — least privilege, one policy per secret path
              # ----------------------------------------------------------------
              echo "[6/7] Writing Vault policies..."

              vault policy write grafana-policy - <<'POLICY'
              path "secret/data/grafana" {
                capabilities = ["read"]
              }
              POLICY

              vault policy write argocd-policy - <<'POLICY'
              path "secret/data/argocd" {
                capabilities = ["read"]
              }
              POLICY

              vault policy write app-policy - <<'POLICY'
              path "secret/data/apps/*" {
                capabilities = ["read"]
              }
              POLICY

              # ----------------------------------------------------------------
              # KUBERNETES AUTH ROLES
              # TTL=1h: tokens are short-lived and auto-rotated by ESO
              # ----------------------------------------------------------------
              echo "[7/7] Binding service accounts to policies..."

              vault write auth/kubernetes/mgmt/role/grafana \
                bound_service_account_names=prometheus-grafana \
                bound_service_account_namespaces=observability \
                policies=grafana-policy \
                ttl=1h

              vault write auth/kubernetes/mgmt/role/argocd \
                bound_service_account_names=argocd-server \
                bound_service_account_namespaces=argocd \
                policies=argocd-policy \
                ttl=1h

              vault write auth/kubernetes/dev/role/app \
                bound_service_account_names=default \
                bound_service_account_namespaces=podtato-app \
                policies=app-policy \
                ttl=1h

              vault write auth/kubernetes/staging/role/app \
                bound_service_account_names=default \
                bound_service_account_namespaces=podtato-app \
                policies=app-policy \
                ttl=1h

              echo ""
              echo "Vault configuration complete."